# 订阅消息防重机制说明

## 问题背景

在微信小程序订阅消息功能中，可能存在以下情况导致同一消息被多次发送：

1. **系统异常重试**：服务重启或异常恢复时可能重复发送
2. **并发请求**：同时存在多个发送请求
3. **人为误操作**：用户多次触发相同操作

这会造成：
- 用户体验不佳（收到重复消息）
- 浪费消息配额（每次订阅有次数限制）
- 增加微信 API 调用次数

## 解决方案

采用**独立的消息发送记录表**来实现防重机制。

### 设计思路

1. **独立表设计**：创建 `subscribe_message_logs` 表专门记录消息发送情况
2. **唯一索引约束**：通过数据库层面的唯一索引防止重复
3. **状态追踪**：记录每条消息的发送状态（发送中、成功、失败）
4. **发送前检查**：每次发送前先查询是否已成功发送过

### 核心表结构

```sql
CREATE TABLE subscribe_message_logs (
  id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
  template_id VARCHAR(100) NOT NULL COMMENT '消息模板ID',
  template_type VARCHAR(50) NOT NULL COMMENT '模板类型',
  business_type VARCHAR(50) NOT NULL COMMENT '业务类型',
  business_id BIGINT UNSIGNED NOT NULL COMMENT '业务关联ID',
  receiver_user_id BIGINT UNSIGNED NOT NULL COMMENT '接收人用户ID',
  receiver_openid VARCHAR(100) NOT NULL COMMENT '接收人openid',
  message_data JSON NOT NULL COMMENT '消息数据内容',
  send_status TINYINT(1) NOT NULL DEFAULT 0 COMMENT '0-发送中，1-成功，2-失败',
  send_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  error_code VARCHAR(50) DEFAULT NULL,
  error_message TEXT DEFAULT NULL,
  
  -- 防重核心：唯一索引
  UNIQUE INDEX uk_business_template_receiver (
    business_type, business_id, template_type, receiver_user_id
  )
);
```

### 唯一索引说明

```sql
UNIQUE INDEX uk_business_template_receiver (
  business_type,    -- 业务类型：course_booking, group_course 等
  business_id,      -- 业务ID：具体的预约ID、团课ID等
  template_type,    -- 模板类型：BOOKING_CONFIRM, BOOKING_SUCCESS 等
  receiver_user_id  -- 接收人用户ID
)
```

这个唯一索引确保：**同一业务的同一类型消息，对同一用户只能发送一次**

## 工作流程

### 发送流程

```
1. 接收发送请求
    ↓
2. 检查是否已发送
   SubscribeMessageLog.isMessageSent(
     businessType,
     businessId,
     templateType,
     receiverUserId
   )
    ↓
3. 已发送？
   是 → 跳过发送，返回 true
   否 → 继续下一步
    ↓
4. 创建发送记录（状态：发送中）
   SubscribeMessageLog.recordMessage(...)
    ↓
5. 调用微信 API 发送消息
   wechatUtil.sendTemplateMessage(...)
    ↓
6. 更新发送状态
   成功 → send_status = 1
   失败 → send_status = 2，记录error_code和error_message
```

### 防重检查逻辑

```javascript
// 检查是否已发送
const alreadySent = await SubscribeMessageLog.isMessageSent(
  'course_booking',   // 业务类型
  booking.id,         // 业务ID
  'BOOKING_CONFIRM',  // 模板类型
  receiverUser.id     // 接收人ID
);

if (alreadySent) {
  logger.info('消息已发送过，跳过重复发送');
  return true;
}
```

### 记录发送状态

```javascript
// 创建发送记录
const messageLog = await SubscribeMessageLog.recordMessage({
  templateId: 'xxx',
  templateType: 'BOOKING_CONFIRM',
  businessType: 'course_booking',
  businessId: booking.id,
  receiverUserId: receiverUser.id,
  receiverOpenid: receiverUser.openid,
  messageData: messageData,
  pagePath: page,
  sendStatus: 0  // 发送中
});

// 发送消息
const result = await wechatUtil.sendTemplateMessage(...);

// 更新状态
if (result) {
  await messageLog.updateSendStatus(1); // 成功
} else {
  await messageLog.updateSendStatus(2, 'SEND_FAILED', '消息发送失败'); // 失败
}
```

## 实现文件

### 1. 数据库模型
**文件**：`src/shared/models/SubscribeMessageLog.js`

**核心方法**：
- `isMessageSent()` - 检查消息是否已发送
- `recordMessage()` - 记录消息发送
- `updateSendStatus()` - 更新发送状态
- `incrementRetryCount()` - 增加重试次数

### 2. 迁移脚本
**文件**：`scripts/004_create_subscribe_message_logs_table.js`

**运行方法**：
```bash
node scripts/004_create_subscribe_message_logs_table.js
```

### 3. 服务集成
**文件**：`src/shared/services/subscribeMessageService.js`

**改动**：
- 引入 `SubscribeMessageLog` 模型
- 在 `sendBookingConfirmNotice()` 中添加防重检查
- 在 `sendBookingSuccessNotice()` 中添加防重检查

## 测试验证

### 测试场景1：正常发送

```
1. 创建课程预约
2. 查询 subscribe_message_logs 表
3. 应该有一条记录，send_status = 1
```

### 测试场景2：防止重复发送

```
1. 创建课程预约（第一次）
2. 模拟系统异常，再次尝试发送（第二次）
3. 第二次应该被跳过
4. 查询 subscribe_message_logs 表
5. 应该只有一条记录
6. 日志中应该有 "消息已发送过，跳过重复发送"
```

### 测试场景3：失败重试

```
1. 创建课程预约
2. 模拟微信 API 返回失败
3. 查询 subscribe_message_logs 表
4. send_status = 2（失败）
5. 有 error_code 和 error_message
6. 可以手动重新发送（因为之前是失败状态）
```

## 查询示例

### 查看某个预约的消息发送情况

```sql
SELECT 
  id,
  template_type,
  receiver_user_id,
  send_status,
  send_time,
  error_message
FROM subscribe_message_logs
WHERE business_type = 'course_booking'
  AND business_id = 123;  -- 预约ID
```

### 统计消息发送成功率

```sql
SELECT 
  template_type,
  COUNT(*) as total,
  SUM(CASE WHEN send_status = 1 THEN 1 ELSE 0 END) as success,
  SUM(CASE WHEN send_status = 2 THEN 1 ELSE 0 END) as failed,
  ROUND(SUM(CASE WHEN send_status = 1 THEN 1 ELSE 0 END) * 100.0 / COUNT(*), 2) as success_rate
FROM subscribe_message_logs
GROUP BY template_type;
```

### 查看最近的失败记录

```sql
SELECT 
  id,
  template_type,
  business_id,
  receiver_user_id,
  error_code,
  error_message,
  send_time
FROM subscribe_message_logs
WHERE send_status = 2
ORDER BY send_time DESC
LIMIT 10;
```

## 优势总结

### 1. 可靠的防重机制
- ✅ 数据库唯一索引从根本上防止重复
- ✅ 即使并发请求也能有效防止

### 2. 完整的历史记录
- ✅ 所有发送记录可追溯
- ✅ 失败原因清晰可查
- ✅ 便于问题排查和优化

### 3. 灵活的扩展性
- ✅ 支持多种业务类型（课程、团课等）
- ✅ 支持多种模板类型
- ✅ 易于添加新的消息场景

### 4. 便于统计分析
- ✅ 可统计各类消息的发送情况
- ✅ 可分析发送成功率
- ✅ 可监控异常情况

## 后续优化方向

### 1. 失败重试机制
- 对发送失败的消息自动重试
- 设置最大重试次数和重试间隔
- 记录每次重试的结果

### 2. 消息队列
- 引入消息队列（Redis、RabbitMQ等）
- 实现异步批量发送
- 提高系统吞吐量

### 3. 监控告警
- 发送失败率超过阈值时告警
- 消息积压告警
- 性能监控

### 4. 数据归档
- 定期归档历史数据
- 保留最近N天的数据在主表
- 历史数据移至归档表

## 总结

通过创建独立的 `subscribe_message_logs` 表并利用数据库唯一索引，我们实现了一个可靠、灵活且易于扩展的消息防重机制。这个方案不仅解决了重复发送的问题，还为后续的统计分析和问题排查提供了完整的数据基础。

