# 订阅消息配额优化说明

## 📋 优化背景

在之前的实现中，订阅消息发送流程如下：
1. 检查是否已发送（防重）
2. 发送微信订阅消息
3. 根据微信返回结果更新配额

这种方式存在以下问题：
- **浪费API调用**：配额为0时仍然调用微信API，导致请求失败
- **浪费日志存储**：失败的发送也会记录到 `subscribe_message_logs` 表
- **用户体验差**：明知没有配额还尝试发送，增加无效操作

## ✅ 优化方案

### 1️⃣ 新增配额检查方法

在 `UserSubscribeQuota` 模型中新增 `hasQuota` 方法：

```javascript
/**
 * 类方法：检查用户是否有剩余配额
 * @param {number} userId - 用户ID
 * @param {string} templateType - 模板类型
 * @returns {Promise<boolean>} 是否有剩余配额
 */
UserSubscribeQuota.hasQuota = async function(userId, templateType) {
  const quota = await this.findOne({
    where: {
      user_id: userId,
      template_type: templateType
    }
  });
  
  // 如果没有记录，返回 false；如果有记录，检查 remaining_quota > 0
  return quota ? quota.remaining_quota > 0 : false;
};
```

### 2️⃣ 优化发送流程

在所有订阅消息发送函数中，添加配额预检查：

```javascript
// 检查用户配额
const hasQuota = await UserSubscribeQuota.hasQuota(receiverUser.id, 'BOOKING_CONFIRM');
if (!hasQuota) {
  logger.info('用户订阅配额不足，跳过发送预约确认提醒', {
    userId: receiverUser.id,
    bookingId: booking.id
  });
  return false;
}
```

### 3️⃣ 新的发送流程

```
用户触发消息发送
    ↓
检查必要参数
    ↓
检查用户 openid
    ↓
【新增】检查本地配额 → 配额 = 0？ → ❌ 直接返回 false（不发送，不记录日志）
    ↓
检查是否已发送（防重）
    ↓
检查是否已发送成功（并发防重）
    ↓
创建/更新发送日志
    ↓
调用微信 API
    ↓
根据结果更新配额和日志状态
```

## 📊 优化效果

### ✅ 减少无效调用
- **之前**：配额为0时仍调用微信API，每次都返回 43101 错误
- **现在**：配额为0时直接跳过，不调用微信API

### ✅ 减少日志记录
- **之前**：即使配额为0，也会创建 `send_status = 2` 的失败日志
- **现在**：配额为0时不创建任何日志，保持日志的有效性

### ✅ 更快的响应速度
- **之前**：需要等待微信API返回错误
- **现在**：本地配额检查，毫秒级响应

### ✅ 更清晰的日志
- **之前**：大量 43101 错误日志混杂
- **现在**：只有"配额不足"的信息日志，真正的发送失败更容易定位

## 🔧 涉及的文件

### 修改的文件

1. **src/shared/models/UserSubscribeQuota.js**
   - 新增 `hasQuota()` 方法

2. **src/shared/services/subscribeMessageService.js**
   - `sendBookingConfirmNotice()` - 添加配额检查
   - `sendBookingSuccessNotice()` - 添加配额检查
   - `sendBookingCancelNotice()` - 添加配额检查
   - `sendBookingReminderNotice()` - 添加配额检查

## 📝 使用示例

### 场景1：用户有配额
```javascript
// user_subscribe_quotas 表中该用户的 BOOKING_CONFIRM 类型 remaining_quota = 3

await SubscribeMessageService.sendBookingConfirmNotice({...});
// 流程：
// 1. hasQuota() → true ✓
// 2. 继续正常发送流程
// 3. 发送成功，配额减为 2
```

### 场景2：用户无配额
```javascript
// user_subscribe_quotas 表中该用户的 BOOKING_CONFIRM 类型 remaining_quota = 0

await SubscribeMessageService.sendBookingConfirmNotice({...});
// 流程：
// 1. hasQuota() → false ✗
// 2. 记录日志："用户订阅配额不足，跳过发送预约确认提醒"
// 3. 直接返回 false
// 4. 不调用微信API，不创建 subscribe_message_logs 记录
```

### 场景3：用户从未授权
```javascript
// user_subscribe_quotas 表中找不到该用户的记录

await SubscribeMessageService.sendBookingConfirmNotice({...});
// 流程：
// 1. hasQuota() → false ✗（没有记录视为无配额）
// 2. 记录日志："用户订阅配额不足，跳过发送预约确认提醒"
// 3. 直接返回 false
```

## 🎯 配额同步机制

### 正常流程（有配额）
```
本地配额: 3
    ↓
检查: hasQuota() = true ✓
    ↓
发送成功
    ↓
decreaseQuota()
    ↓
本地配额: 2
```

### 微信返回配额不足（本地配额不准确）
```
本地配额: 1（实际微信侧已用尽）
    ↓
检查: hasQuota() = true ✓
    ↓
发送失败（errcode: 43101）
    ↓
resetQuota()
    ↓
本地配额: 0（同步为准确值）
```

## 🔍 监控查询

### 查看被配额限制的发送尝试
```sql
-- 查看最近的配额不足日志（需要查看应用日志文件）
tail -f src/shared/logs/$(date +%Y-%m-%d).log | grep "用户订阅配额不足"
```

### 查看用户配额情况
```sql
-- 查看所有用户配额
SELECT 
  user_id,
  template_type,
  remaining_quota,
  total_quota,
  last_authorized_at,
  last_sent_at
FROM user_subscribe_quotas
ORDER BY remaining_quota ASC, last_sent_at DESC;

-- 查看配额为0的用户
SELECT 
  user_id,
  template_type,
  last_sent_at
FROM user_subscribe_quotas
WHERE remaining_quota = 0
ORDER BY last_sent_at DESC;
```

### 查看实际发送记录
```sql
-- 只查看真正尝试发送的记录（配额检查通过的）
SELECT 
  business_id,
  receiver_user_id,
  template_type,
  send_status,
  send_time,
  error_code
FROM subscribe_message_logs
WHERE template_type = 'BOOKING_CONFIRM'
ORDER BY send_time DESC
LIMIT 20;
```

## ⚡ 性能提升

### API 调用减少
- **场景**：100个用户，其中20个配额为0
- **之前**：100次微信API调用（20次返回43101错误）
- **现在**：80次微信API调用（20次本地拦截）
- **提升**：减少20%的API调用

### 日志减少
- **场景**：同上
- **之前**：100条 `subscribe_message_logs` 记录（20条失败记录）
- **现在**：80条 `subscribe_message_logs` 记录
- **提升**：日志表更干净，失败记录更有价值

## 📌 注意事项

1. **配额初始化**
   - 用户首次使用时，`user_subscribe_quotas` 表中没有记录
   - `hasQuota()` 返回 `false`，不会发送消息
   - 需要用户在前端完成授权后，调用 `POST /api/h5/wechat/subscribe-quotas` 接口上报

2. **配额同步**
   - 本地配额以微信实际发送结果为准
   - 发送成功 → `decreaseQuota()`
   - 发送失败（43101）→ `resetQuota()`

3. **日志级别**
   - 配额不足的日志级别为 `info`，不是 `warn` 或 `error`
   - 这是正常业务流程，不需要告警

4. **返回值**
   - 配额不足时返回 `false`
   - 调用方需要理解：返回 `false` 不一定是错误，可能是配额不足

## 🚀 后续优化建议

1. **配额预警**
   - 当用户配额 ≤ 5 时，在小程序端提示用户重新授权
   - 可通过 `GET /api/h5/wechat/subscribe-quotas` 接口查询配额

2. **批量授权提醒**
   - 定期统计配额为0的活跃用户
   - 通过其他渠道（如系统消息）提醒用户授权

3. **配额分析**
   - 统计各类消息的配额消耗速度
   - 分析用户授权率和消息发送成功率
   - 优化授权引导流程

---

**更新时间**：2025-11-12  
**版本**：v2.0

